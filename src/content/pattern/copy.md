---
title: Copy a graph
---

A key benefit of building a site as a graph is that we can seamlessly move between browsing that graph and rendering that graph as static content.

## Build pipeline

When working with graphs, the "build" pipeline can be conceptually simple:

<figure>
  Real markdown files → Virtual HTML files → Real HTML files
</figure>

1. We define a graph of the source markdown content — as an object, as real files, or as values generated by a function.
1. We use one or more transforms to create a virtual graph of the final content that we want — here, HTML. We can directly serve and browse this virtual graph during development.
1. We want to copy the virtual graph of HTML pages into some persistent form such as real `.html` files. We can then deploy these files.

For the last step, we could write the files out directly using a file system API. But we've gained a lot by abstracting away the file system read operations; we can make similar gains by abstracting away the file system write operations too.

## Setting graph values

Let's extend our AsyncDictionary interface with an optional method `set(key, value)`. This updates the graph so that getting the corresponding `key` will now return the new `value`. We can supporting deleting a key/value from the graph by declaring that, if `value` is undefined, the key and its corresponding value will be removed from the graph.

This is straightforward for our object-based graph:

```js
  /* In src/set/ObjectGraph.js */

  async set(key, value) {
    if (value === undefined) {
      delete this.obj[key];
    } else {
      this.obj[key] = value;
    }
  }
```

And a fair bit of work for our file system-based graph:

```js
  /* In src/set/FilesGraph.js */

  async set(key, value) {
    // Where are we going to write this value?
    const destPath = path.resolve(this.dirname, key ?? "");

    if (value === undefined) {
      // Delete the file or directory.
      let stats;
      try {
        stats = await stat(destPath);
      } catch (/** @type {any} */ error) {
        if (error.code === "ENOENT" /* File not found */) {
          return;
        }
        throw error;
      }
      if (stats.isDirectory()) {
        // Delete directory.
        await fs.rm(destPath, { recursive: true });
      } else if (stats) {
        // Delete file.
        await fs.unlink(destPath);
      }
    }

    const isAsyncDictionary =
      typeof value?.get === "function" &&
      typeof value?.keys === "function";

    if (isAsyncDictionary) {
      // Write out the contents of the value graph to the destination.
      const destGraph = key === undefined ? this : new FilesGraph(destPath);
      for await (const subKey of value) {
        const subValue = await value.get(subKey);
        await destGraph.set(subKey, subValue);
      }
    } else {
      // Ensure this directory exists.
      await fs.mkdir(this.dirname, { recursive: true });
      // Write out the value as the contents of a file.
      await fs.writeFile(destPath, value);
    }
  }
```

Half the work here involves handling the case where we want to delete a file or subfolder by passing in an `undefined` value.

The other complex case we handle is when the value itself is an async graph node, and we have to recursively write out that value as a set of files or folders. We didn't have to handle that case specially for `ObjectGraph`, as it's perfectly fine for an `ObjectGraph` instance to have a value which is an async graph.

The file system is not so flexible. The good news is that all this complexity can live inside of the `FilesGraph` class — from the outside, we can just call `set` and trust that the file system will be updated as expected.

This leads to another way to think about async graphs: async graphs are software adapters or drivers for any real or virtual hierarchical storage.

## setDeep

We can now introduce a new helper function, `setDeep(target, source)`, which handles the general case of writing values from the `source` graph into the `target` graph.

```{{'js'}}
/* src/set/setDeep.js */

{{ pattern-intro/set/setDeep.js }}
```

## Build real files from virtual content

We're now ready to build real static files for our site by copying the virtual graph of HTML pages into a real file system folder. All we need to do is wrap a real folder called `distFiles` in a `FilesGraph`:

```{{'js'}}
/* src/set/distFiles.js */

{{ pattern-intro/set/distFiles.js }}
```

And then create a `build.js` utility that copies the virtual graph defined in `siteGraph.js` into that real `dist` folder:

```{{'js'}}
/* src/set/build.js */

{{ pattern-intro/set/build.js }}
```

<span class="tutorialStep"></span> Use this new `build` tool from inside the `src/set` directory to copy the virtual graph into files. The `set` method for `FilesGraph` takes care to create the target directory (`dist`), so it's fine if that directory doesn't exist when we start.

```console
$ cd ../set
$ ls dist
ls: dist: No such file or directory
$ node build
$ ls dist
Alice.html Bob.html   Carol.html index.html more
```

<span class="tutorialStep"></span> Inspect the individual files in the `dist` folder to confirm their contents — or use our `json` utility to dump the entire `dist` folder to the console.

```console
$ node json distFiles.js
{{ @json pattern-intro/set/htmlObject }}
```

We can see that we've generated HTML pages for all the markdown content, and also see that each level of this tree has an `index.html` page.

## Browse the built HTML files

You could now deploy the HTML files in the `dist` folder anywhere, such as a CDN (Content Delivery Network).

<span class="tutorialStep"></span> As a quick test, serve the `dist` folder with any static server, such as [http-server](https://github.com/http-party/http-server).

```console
$ npx http-server dist
Starting up http-server, serving dist
```

(You could also temporarily hack `serve.js` to serve the graph defined by `distFiles.js` instead of `siteGraph.js`. Everything here's a graph, and you can serve any of those graphs the same way.)

<span class="tutorialStep"></span> Browse to the static server and confirm that the static results are the same as what you can see running the dynamically-generated graph.

The results will look identical, but a key difference is that no real work is necessary to display the HTML files served from the `dist` folder.

<span class="tutorialStep"></span> Before moving on, in the terminal window, stop the server by pressing Ctrl+C.

In this tutorial, the markdown-to-HTML translation happens almost instantly, but in real projects, the data or transformations could easily take some time. Viewing an individual page might require non-trivial work, resulting in a perceptible delay before the page appears. Building the pages into static files performs all the work at once, so your users can browse the resulting static files as fast as the web can deliver them.

We've now solved our original problem: we've created a system in which our team can write content for our web site using markdown, and end up with HTML pages we can deploy.

## A general approach for building things

In this tutorial, we're using real markdown files to create virtual HTML files and then save those as real HTML files. But this type of build pipeline doesn't really have anything to do with the web specifically — HTML pages are just a convenient and common example of content that can be created this way.

You could apply this same async graph pattern in build pipelines for many other kinds of artifacts: data sets, PDF documents, application binaries, etc. The pattern can benefit any situation in which you are transforming graphs of values.

- In some cases, the source information will be an obvious graph. In others, you might start with a single block of content (a document, say) and parse that to construct a virtual graph. Or you might wrap a data set to interpret it as an async graph.
- You can then apply multiple transforms to that source graph to create additional virtual graphs, each one step closer to your desired result.
- Finally, you can save the last virtual graph in some persistent form. That might be a hierarchical set of files as in the example above, or you might reduce the graph in some fashion to a single result, perhaps a single file.

&nbsp;

Next: [Combine graphs](combine.html) »
