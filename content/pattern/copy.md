---
title: Copy a tree
---

A key benefit of building a site as a map-based tree is that we can seamlessly move between viewing that content in the console or the browser.

We can also easily render that tree as regular “static” files (i.e., files that don’t change often). While we could deploy our server as is, deploying the site as static files is much cheaper, faster, and more reliable.

## Build pipeline

Systems for generating static sites have a “build” process that creates a folder with all the site’s files. In many of these systems, the build system and the server work very differently.

But for map-based trees, the "build" pipeline is conceptually very simple:

<figure>
  1: Markdown tree → 2: Virtual HTML tree → 3: Real HTML file tree
</figure>

1. We define a tree of the source markdown content — as an object, as real files, or as values generated by a function.
1. We use one or more transforms to create a virtual tree of the final content that we want — here, HTML. We can directly serve and browse this virtual tree during development.
1. We want to copy the virtual tree of HTML pages into some persistent form such as real `.html` files. We can then deploy these files.

The transformation from tree 1 to tree 2 is handled by our `site.js` file — but how should we go from tree 2 to tree 3?

The key insight is that the set of static files we want to end up with is exactly the same as the virtual tree 2. We just need to _copy that tree_ to produce tree 3!

## Copying a map-based tree

We can write a `copy` function that copies one map-based tree into another:

```js
/* src/map/copy.js */

${ pattern/map/copy.js }
```

The `source` tree can be read-only or read/write `Map`; the `target` map has to be read/write.

## Build real files from virtual content

We're now ready to build real static files for our site by copying the virtual tree of HTML pages into a real file system folder. All we need to do is wrap a real `build` folder in a read/write `FileMap`:

```js
/* src/map/buildFiles.js */

${ pattern/map/buildFiles.js }
```

We can create a `build.js` script that copies the virtual tree defined in `site.js` into that real `build` folder:

```${'js'}
/* src/map/build.js */

${ pattern/map/build.js }
```

This first clears the contents of the `build` folder, then copies everything in the site tree into that folder.

## Building

<span class="tutorialStep"></span> Use this new `build` script from inside the `src/map` directory to copy the virtual site into the `build` folder:

```console
$ cd ../map
$ ls build
ls: build: No such file or directory
$ node build
$ ls build
index.html      posts
```

<span class="tutorialStep"></span> Inspect the individual files in the `build` folder to confirm their contents. You can also use our `json` utility to dump the entire `build` to the console:

```console
$ node json buildFiles.js
${ Tree.json(pattern/map/buildFiles.js) + "\n" }
```

We can confirm that this is the same JSON we saw before when dumping `site.js` to the console.

## Browse the built HTML files

You could now deploy the HTML files in the `dist` folder anywhere, such as a CDN (Content Delivery Network).

<span class="tutorialStep"></span> As a quick test, serve the `build` folder with any static server, such as [http-server](https://github.com/http-party/http-server).

```console
$ npx http-server build
Starting up http-server, serving build
```

(You could also temporarily hack `serve.js` to serve the tree defined by `builtFiles.js` instead of `siteTree.js`. Everything here's a map-based tree, and you can serve any of those trees the same way.)

<span class="tutorialStep"></span> Browse to the static server and confirm that the static results are the same as what you can see running the dynamically-generated tree.

The results will look identical, but a key difference is that no real work is necessary to display the HTML files served from the `build` folder.

<span class="tutorialStep"></span> Before moving on, in the terminal window, stop the server by pressing Ctrl+C.

In this tutorial, the markdown-to-HTML translation happens almost instantly, but in real projects, the data or transformations could easily take some time. Viewing an individual page might require non-trivial work, resulting in a perceptible delay before the page appears. Building the pages into static files performs all the work at once, so your users can browse the resulting static files as fast as the web can deliver them.

We've now solved our original problem: we've created a system in which our team can write content for our web site using markdown, and end up with HTML pages we can deploy.

## A general approach for building things

In this tutorial, we're using real markdown files to create virtual HTML files and then save those as real HTML files. But this type of build pipeline doesn't really have anything to do with the web specifically — HTML pages are just a convenient and common example of content that can be created this way.

You could apply this same tree pattern in build pipelines for many other kinds of artifacts: data sets, PDF documents, application binaries, etc. The pattern can benefit any situation in which you are transforming trees of values.

- In some cases, the source information will be an obvious tree. In others, you might start with a single block of content (a document, say) and parse that to construct a virtual tree.
- You can then apply multiple transforms to that source tree to create additional virtual trees, each one step closer to your desired result.
- Finally, you can save the last virtual tree in some persistent form. That might be a hierarchical set of files as in the example above, or you might reduce the tree in some fashion to a single result, perhaps a single file.

In some cases, the source information will reside on a server. You could copy that information locally — but you could also read the data from its server location. To account for the slower speed of reading from a network, you can extend the map paradigm to asynchronous data.

&nbsp;

Next: [Asynchronous maps](async.html) »
